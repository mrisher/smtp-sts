<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<rfc ipr="trust200902" category="std" docName="draft-ietf-uta-mta-sts-01">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private=""?>
<?rfc topblock="yes"?>
<?rfc comments="no"?>
<front>
<title abbrev="MTA-STS">SMTP MTA Strict Transport Security (MTA-STS)</title>

<author initials="D." surname="Margolis" fullname="Daniel Margolis">
<organization>Google, Inc</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>dmargolis (at) google.com</email>
<uri></uri>
</address>
</author>
<author initials="M." surname="Risher" fullname="Mark Risher">
<organization>Google, Inc</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>risher (at) google (dot com)</email>
<uri></uri>
</address>
</author>
<author initials="B." surname="Ramakrishnan" fullname="Binu Ramakrishnan">
<organization>Yahoo!, Inc</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>rbinu (at) yahoo-inc (dot com)</email>
<uri></uri>
</address>
</author>
<author initials="A." surname="Brotman" fullname="Alexander Brotman">
<organization>Comcast, Inc</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>alexander_brotman (at) cable.comcast (dot com)</email>
<uri></uri>
</address>
</author>
<author initials="J." surname="Jones" fullname="Janet Jones">
<organization>Microsoft, Inc</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>janet.jones (at) microsoft (dot com)</email>
<uri></uri>
</address>
</author>
<date year="2016" month="July" day="8"/>

<area>Applications</area>
<workgroup>Using TLS in Applications</workgroup>
<keyword></keyword>


<abstract>
<t>SMTP MTA-STS is a mechanism enabling mail service providers to declare their
ability to receive TLS-secured connections, to declare particular methods for
certificate validation, and to request that sending SMTP servers report upon
and/or refuse to deliver messages that cannot be delivered securely.
</t>
</abstract>


</front>

<middle>

<section anchor="introduction" title="Introduction">
<t>The STARTTLS extension to SMTP <xref target="RFC3207"/> allows SMTP clients and hosts to
negotiate the use of a TLS channel for secure mail transmission.
</t>
<t>While such <spanx style="emph">opportunistic</spanx> encryption protocols provide a high barrier against
passive man-in-the-middle traffic interception, any attacker who can delete
parts of the SMTP session (such as the &quot;250 STARTTLS&quot; response) or who can
redirect the entire SMTP session (perhaps by overwriting the resolved MX record
of the delivery domain) can perform downgrade or interception attacks.
</t>
<t>This document defines a mechanism for recipient domains to publish policies
specifying:
</t>
<t>
<list style="symbols">
<t>whether MTAs sending mail to this domain can expect TLS support</t>
<t>how to validate the names of the domain's MX hosts</t>
<t>what a conforming client should do with messages when TLS cannot be
 successfully negotiated</t>
</list>
</t>
<t>The mechanism described is separated into three logical components:
</t>
<t>
<list style="numbers">
<t>policy semantics: whether senders can expect a server for the
  recipient domain to support TLS encryption</t>
<t>policy discovery &amp; authentication: how to discover a domain's published
  STS policy and determine the authenticity of that policy</t>
<t>failure handling: what sending MTAs should do in the case of policy
  failures</t>
</list>
</t>

<section anchor="terminology" title="Terminology">
<t>The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT,
SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when
they appear in this document, are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>We also define the following terms for further use in this document:
</t>
<t>
<list style="symbols">
<t>STS Policy: A definition of the expected TLS availability and behavior, as
well as the desired actions for a given domain when a sending MTA encounters
different results.</t>
<t>Policy Domain: The domain against which an STS Policy is defined. (For
example, when sending mail to &quot;alice@example.com&quot;, the policy domain is
&quot;example.com&quot;.)</t>
<t>Policy Authentication: Authentication of the STS policy retrieved for a recipient
domain by the sender.</t>
</list>
</t>
</section>
</section>

<section anchor="related-technologies" title="Related Technologies">
<t>The DANE TLSA record <xref target="RFC7672"/> is similar, in that DANE is also designed to
upgrade opportunistic, unauthenticated encryption into required, authenticated
encryption. DANE requires DNSSEC <xref target="RFC4033"/> for authentication; the mechanism
described here instead relies on certificate authorities (CAs) and does not
require DNSSEC.
</t>

<section anchor="differences-from-dane" title="Differences from DANE">
<t>The primary difference between the mechanism described here and DANE is that
DANE requires the use of DNSSEC to authenticate DANE TLSA records, whereas SMTP
MTA-STS relies on the certificate authority (CA) system to avoid interception.
(For a thorough discussion of this trade-off, see the section <spanx style="emph">Security</spanx>
<spanx style="emph">Considerations</spanx>.)
</t>
<t>In addition, SMTP MTA-STS provides an optional report-only mode, enabling soft
deployments to detect policy failures.
</t>
</section>
</section>

<section anchor="policy-semantics" title="Policy Semantics">
<t>SMTP MTA-STS policies are distributed via a &quot;well known&quot; HTTPS endpoint in the
Policy Domain. A corresponding TXT record in the DNS signals to sending MTAs the
presence of a policy file. The character content of the TXT record is encoded as
US-ASCII.
</t>
<t><spanx style="strong">The MTA-STS TXT record MUST specify the following fields:</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">v</spanx>: (plain-text, required). Currently only &quot;STSv1&quot; is supported.</t>
<t><spanx style="verb">id</spanx>: (plain-text, required). A short string used to track policy updates.
This string MUST uniquely identify a given instance of a policy, such that
senders can determine when the policy has been updated by comparing to the <spanx style="verb">id</spanx>
of a previously seen policy.</t>
</list>
</t>
<t><spanx style="strong">Policies MUST specify the following fields in JSON</spanx> <xref target="RFC4627"/> <spanx style="strong">format:</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">version</spanx>: (plain-text, required). Currently only &quot;STSv1&quot; is supported.</t>
<t><spanx style="verb">mode</spanx>: (plain-text, required). If &quot;enforce&quot;, the receiving MTA requests that
messages be delivered only if they conform to the STS policy. If &quot;report&quot; the
receiving MTA requests that failure reports be delivered, as specified
by the <spanx style="verb">rua</spanx> parameter.</t>
<t><spanx style="verb">mx</spanx>: MX patterns (list of plain-text MX match patterns, required). One or
more comma-separated patterns matching the expected MX for this domain. For
example, <spanx style="verb">["*.example.com", "*.example.net"]</spanx> indicates that mail for this
domain might be handled by any MX whose hostname is a subdomain of
&quot;example.com&quot; or &quot;example.net&quot;. The semantics for these patterns should be the
ones found in the &quot;Checking of Wildcard Certificates&quot; rules in Section 6.4.3
of <xref target="RFC6125"/>.</t>
<t><spanx style="verb">max_age</spanx>: Max lifetime of the policy (plain-text positive integer seconds).
Well-behaved clients SHOULD cache a policy for up to this value from last
policy fetch time.</t>
</list>
</t>
<t>A lenient parser SHOULD accept TXT record sand policy files which are
syntactically valid (i.e. valid key-value pairs or valid JSON) implementing a
superset of this specification, in which case unknown values SHALL be ignored.
</t>

<section anchor="formal-definition" title="Formal Definition">

<section anchor="txt-record" title="TXT Record">
<t>An example TXT record is as below:
</t>

<figure align="center"><artwork align="center">
_mta_sts  IN TXT ( "v=STSv1; id=20160831085700Z;" )
</artwork></figure>
<t>The formal definition of the <spanx style="verb">_mta_sts</spanx> TXT record, defined using <xref target="RFC5234"/>,
is as follows:
</t>

<figure align="center"><artwork align="center">
sts-text-record = sts-version *WSP %x3B *WSP sts-id

sts-version     = "v" *WSP "=" *WSP %x53 %x54        ; "STSv1" 
                  %x53 %x76 %x31

sts-id          = "id" *WSP "=" *WSP 1*32(ALPHA / DIGIT) 
</artwork></figure>
</section>

<section anchor="smtp-mtasts-policy" title="SMTP MTA-STS Policy">
<t>An example policy is as below:
</t>

<figure align="center"><artwork align="center">
{
  "version": "STSv1",
  "mode": "enforce",
  "mx": ["*.mail.example.com"],
  "max_age": 123456
}
</artwork></figure>
<t>The formal definition of the SMTP MTA-STS policy, using <xref target="RFC5234"/>, is as
follows:
</t>

<figure align="center"><artwork align="center">
sts-record      = WSP %x7B WSP  ; { left curly bracket
                  sts-element   ; comma-separated
                  [             ; list
                  WSP %x2c WSP  ; of
                  sts-element   ; sts-elements
                  ]
                  WSP %x7d WSP  ; } right curly bracket

sts-element     = sts-version / sts-mode / sts-id / sts-mx / sts-max_age

sts-version     = %x22 "version" %x22 *WSP %x3a *WSP ; "version":
                  %x22 %x53 %x54 %x53 %x76 %x31      ; "STSv1"

sts-mode        = %x22 "mode" %x22 *WSP %x3a *WSP    ; "mode":
                  %x22 ("report" / "enforce") %x22   ; "report"/"enforce"

sts-mx          = %x22 "mx" $x22 *WSP %x3a *WSP      ; "mx":
                  %x5B                               ; [
                  domain-match                       ; comma-separated list
                  [WSP %x2c domain-match WSP]        ; of domain-matches
                  %x5B                               ; ]

sts-max_age     = %x22 "max_age" %x22 *WSP $x3a *WSP ; "max_age":
                  1*10DIGIT                          ; some digits

domain-match    = %x22 1*(dtext / "*") *("."         ; wildcard or label
                  1*dtext) %x22                      ; with 0+ more labels

dtext           = ALPHA / DIGIT / %2D                ; A-Z, a-z, 0-9, "-" 
</artwork></figure>
</section>
</section>

<section anchor="policy-expiration" title="Policy Expiration">
<t>In order to resist attackers inserting a fraudulent policy, SMTP MTA-STS
policies are designed to be long-lived, with an expiry typically greater than
two weeks.  Policy validity is controlled by the lifetime indicated in the
policy (&quot;max_age=&quot;). Senders SHOULD cache a policy (and apply it to all mail to
the recipient domain) until the policy expiration.
</t>
<t>To mitigate the risks of long-lived cached policies (which otherwise may make it
difficult for recipient domains to change infrastructure in ways which the
policy forbids), domains can, at any time, publish an updated policy. As
described in <spanx style="emph">Policy</spanx> <spanx style="emph">Application</spanx>, senders MUST fetch a new policy before
treating a validation failure as a permanent delivery failure.
</t>

<section anchor="policy-updates" title="Policy Updates">
<t>Updating the policy requires that the owner make changes in two places: the
<spanx style="verb">_mta_sts</spanx> TXT record in the Policy Domain's DNS zone and at the corresponding
HTTPS endpoint. In the case where the HTTPS endpoint has been updated but the
TXT record has not been, senders will not know there is a new policy released
and may thus continue to use old, previously cached versions.  Recipients should
thus expect a policy will continue to be used by senders until both the HTTPS
and TXT endpoints are updated and the TXT record's TTL has passed.
</t>
</section>
</section>

<section anchor="policy-discovery--authentication" title="Policy Discovery &amp; Authentication">
<t>Senders discover a recipient domain's MTA-STS policy by fetching a TXT record
from the recipient domain's DNS zone with the name <spanx style="verb">_mta_sts</spanx>. A valid TXT
record at <spanx style="verb">_mta_sts.example.com</spanx> indicates that the domain <spanx style="verb">example.com</spanx>
supports MTA-STS.
</t>
<t>When sending to a recipient domain for which a valid TXT record exists, a
compliant sender will then fetch via the GET method an HTTPS resource containing
the policy body from a host at the <spanx style="verb">policy.mta-sts</spanx> subdomain of the policy
domain, using a &quot;well-known&quot; path of <spanx style="verb">.well-known/mta-sts/current</spanx>. For
<spanx style="verb">example.com</spanx>, this would be
<spanx style="verb">https://policy.mta-sts.example.com/.well-known/mta-sts/current</spanx>.
</t>
<t>When fetching a new policy or updating a policy, the HTTPS endpoint MUST present
a TLS certificate which is valid for the <spanx style="verb">policy.mta-sts</spanx> host (as described in
<xref target="RFC6125"/>), chain to a root CA that is trusted by the sending CA, and be
non-expired.
</t>
<t>A policy which has not ever been successfully authenticated MUST NOT be used to
reject mail.
</t>
</section>

<section anchor="policy-validation" title="Policy Validation">
<t>When sending to an MX at a domain for which the sender has a valid and
non-expired SMTP MTA-STS policy, a sending MTA honoring SMTP MTA-STS MUST
validate that the recipient MX matches the <spanx style="verb">mx</spanx> pattern from the recipient
domain's policy, supports STARTTLS, and offers a valid PKIX based TLS
certificate. The certificate presented by the receiving MX MUST be valid for the
MX name and chain to a root CA that is trusted by the sending MTA. The
certificate MUST have a CN or SAN matching the MX hostname (as described in
<xref target="RFC6125"/>) and be non-expired.
</t>
<t>Note that this section does not dictate the behavior of sending MTAs when
policies fail to validate; in particular, validation failures of policies which
specify &quot;report only&quot; mode MUST NOT be interpreted as delivery failures, as
described in the section <spanx style="emph">Policy</spanx> <spanx style="emph">Application</spanx>.
</t>
</section>

<section anchor="policy-application" title="Policy Application">
<t>When sending to an MX at a domain for which the sender has a valid, non-expired
STS policy, a sending MTA honoring SMTP MTA-STS applies the result of a policy
validation one of two ways, depending on the value of the policy <spanx style="verb">mode</spanx> field:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">report</spanx>: In this mode, sending MTAs merely send a report (as described in the
<spanx style="verb">TLSRPT</spanx> specification (TODO: add ref)) indicating policy application
failures. This can be used for &quot;soft&quot; deployments, to ensure a policy will not
cause domain-wide mail delivery failures while being adopted or during
infrastructure changes.</t>
<t><spanx style="verb">enforce</spanx>: In this mode, sending MTAs SHOULD treat STS policy failures as a
mail delivery error, and SHOULD not deliver the message to this host. However,
note that MTAs that honor <spanx style="verb">enforce</spanx> mode MUST first check for the existing of
an updated, authenticated policy before <spanx style="emph">permanently</spanx> failing deliveries. This
is to ensure that failures only occur if a sending MTA is in fact validating
against the most recent version of the recipient domain's policy.</t>
</list>
</t>
<t>Note that despite the presence of an <spanx style="verb">enforce</spanx> policy, STS-aware sending MTAs
may in some cases choose to deliver mail to non-validating MXes due to external
reasons, such as an inability to enforce STS at send-time (i.e., some domains
may validate STS policies offline and only choose to report failures) or
concerns about the completeness of their own trusted CA list.
</t>

<section anchor="mx-preference-in-enforce-mode" title="MX Preference in Enforce Mode">
<t>When applying a policy specifying <spanx style="verb">enforce</spanx> mode, sending MTAs SHOULD select
recipient MXs by first eliminating any MXs at lower priority than the current
host (if in the MX candidate set), then eliminating any non-matching (as
specified by the STS policy) MX hosts from the candidate MX set, and then
attempting delivery to matching hosts as indicated by their MX priority, until
delivery succeeds or the MX candidate set is empty.
</t>
<t>If none of the attempted MX hosts validate according to the policy, the policy
MUST be refreshed at least once, as described in <spanx style="emph">Policy</spanx> <spanx style="emph">Discovery</spanx> <spanx style="emph">&amp;</spanx>
<spanx style="emph">Authentication</spanx>, before a message should be permanently rejected.
</t>
</section>

<section anchor="policy-application-control-flow" title="Policy Application Control Flow">
<t>The control flow for a sending MTA consists of the following steps:
</t>
<t>
<list style="numbers">
<t>Check for a cached, non-expired policy. If none exists and the <spanx style="verb">_mta_sts</spanx> TXT
record is present for the recipient domain, fetch a new policy, authenticate,
and cache it.</t>
<t>Validate candidate MX or MXs against policy. If a valid MX is discovered,
deliver mail and mark cached policy as &quot;successfully applied.&quot;</t>
<t>If no valid recipient MX is found, the cached policy mode is <spanx style="verb">reject</spanx>, and
the cached policy has previously been successfully applied, temporarily fail
the message.</t>
<t>Upon message retries, a message MAY be permanently failed following first
checking for the presence of a new policy (as indicated by the <spanx style="verb">id</spanx> field in
the <spanx style="verb">_mta_sts</spanx> TXT record).</t>
</list>
</t>
</section>
</section>
</section>

<section anchor="iana-considerations" title="IANA Considerations">
<t>A new .well-known URI will be registered in the Well-Known URIs registry as
described below:
</t>
<t>URI Suffix: mta-sts
Change Controller: IETF
</t>
</section>

<section anchor="security-considerations" title="Security Considerations">
<t>SMTP Strict Transport Security attempts to protect against an active attacker
who wishes to intercept or tamper with mail between hosts who support STARTTLS.
There are two classes of attacks considered:
</t>
<t>
<list style="numbers">
<t>Foiling TLS negotiation, for example by deleting the &quot;250 STARTTLS&quot; response
from a server or altering TLS session negotiation. This would result in the
SMTP session occurring over plaintext, despite both parties supporting TLS.</t>
<t>Impersonating the destination mail server, whereby the sender might deliver
the message to an impostor, who could then monitor and/or modify messages
despite opportunistic TLS. This impersonation could be accomplished by
spoofing the DNS MX record for the recipient domain, or by redirecting client
connections intended for the legitimate recipient server (for example, by
altering BGP routing tables).</t>
</list>
</t>
<t>SMTP Strict Transport Security relies on certificate validation via PKIX based TLS
identity checking <xref target="RFC6125"/>. Attackers who are able to obtain a valid certificate
for the targeted recipient mail service (e.g. by compromising a certificate authority)
are thus able to circumvent STS authentication.
</t>
<t>Since we use DNS TXT record for policy discovery, an attacker who is able to
block DNS responses can suppress the discovery of an STS Policy, making the
Policy Domain appear not to have an STS Policy. The caching model described in
<spanx style="emph">Policy</spanx> <spanx style="emph">Expirations</spanx> is designed to resist this attack.
</t>
</section>

<section anchor="contributors" title="Contributors">
<t>Nicolas Lidzborski
Google, Inc
nlidz (at) google (dot com)
</t>
<t>Wei Chuang
Google, Inc
weihaw (at) google (dot com)
</t>
<t>Brandon Long
Google, Inc
blong (at) google (dot com)
</t>
<t>Franck Martin
LinkedIn, Inc
fmartin (at) linkedin (dot com)
</t>
<t>Klaus Umbach
1&amp;1 Mail &amp; Media Development &amp; Technology GmbH
klaus.umbach (at) 1und1 (dot de)
</t>
<t>Markus Laber
1&amp;1 Mail &amp; Media Development &amp; Technology GmbH
markus.laber (at) 1und1 (dot de)
</t>
</section>

<section anchor="appendix-1-validation-pseudocode" title="Appendix 1: Validation Pseudocode">

<figure align="center"><artwork align="center">
policy = policy_from_cache()
if not policy or is_expired(policy):
  policy = policy_from_https_endpoint()  // fetch and authenticate!
  update_cache = true
if policy:
  if invalid_mx_or_tls(policy):  // check MX and TLS cert
    if rua:
      generate_report()
    if p_reject():
      policy = policy_from_https_endpoint()  // fetch and authenticate #2!
      update_cache = true
      if invalid_mx_or_tls(policy):
        reject_message()
        update_cache = false
  if update_cache:
    cache(policy)
</artwork></figure>
</section>

<section anchor="appendix-2-domain-owner-sts-example-record" title="Appendix 2: Domain Owner STS example record">

<section anchor="example-1" title="Example 1">
<t>The owner of example.com wishes to begin using STS with a policy that will
solicit aggregate feedback from receivers without affecting how the messages are
processed, in order to:
</t>
<t>
<list style="symbols">
<t>Verify the identity of MXs that handle mail for this domain</t>
<t>Confirm that its legitimate messages are sent over TLS</t>
<t>Verify the validity of the certificates</t>
<t>Determine how many messages would be affected by a strict policy</t>
</list>
</t>
<t>DNS STS policy indicator TXT record:
</t>

<figure align="center"><artwork align="center">
_mta_sts  IN TXT ( "v=STSv1; id=20160831085700Z;" )
</artwork></figure>
<t>STS policy served from HTTPS endpoint of the policy (recipient) domain, and
is authenticated using the Web PKI mechanism. The policy is fetched using HTTP
GET method.
</t>

<figure align="center"><artwork align="center">
{
  "version": "STSv1",
  "mode": "report",
  "mx": ["*.mail.example.com"],
  "max_age": 123456
}

</artwork></figure>
</section>
</section>

</middle>
<back>
<references title="Normative References">
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3207.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4033.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4627.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7672.xml"?>
</references>

</back>
</rfc>
